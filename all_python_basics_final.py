# -*- coding: utf-8 -*-
"""All python basics - final

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1abGvlLIqUXcnLmCy1yNFGlw8Pj-zDEUT
"""

# variable and print
name="nib"
print(name)

"""# String

"""

# slicing
msg = "Hello, World!"
print(msg[2:5])
print(msg[-1])

s = 'mybacon'
s[2:5] #'bac'
s[0:2]#'my'

s = 'mybacon'
s[:2]#'my'
s[2:]#'bacon'
s[:2] + s[2:]#'mybacon'
s[:]#'mybacon'


s = 'mybacon'
s[-5:-1]#'baco'
s[2:6]#'baco'

s = '12345' * 5 #'1234512345123451234512345'
s[::5]#'11111'
s[4::5]#'55555'
s[::-5]#'55555'
s[::-1]#'5432154321543215432154321'




# String length

hello = "Hello, World!"
print(len(hello))

# check string

s = 'spam'
s in 'I saw spamalot!' # True
s not in 'I saw The Holy Grail!' # True

#formatting

name = "John"
print("Hello, %s!" % name)

name = "John"
age = 23
print("%s is %d years old." % (name, age))

# formatting using format() method

txt1 = "My name is {fname}, I'm {age}".format(fname="John", age=36)
txt2 = "My name is {0}, I'm {1}".format("John", 36)
txt3 = "My name is {}, I'm {}".format("John", 36)

#join

"#".join(["John", "Peter", "Vicky"]) #'John#Peter#Vicky'

#endsWith

"Hello, world!".endswith("!")



# Input

name = input("Enter your name: ")
#Enter your name: Tom
name#'Tom'

"""# Python F string

"""

website = 'Quickref.ME'
f"Hello, {website}"#"Hello, Quickref.ME"

num = 10
f'{num} + 10 = {num + 10}' #'10 + 10 = 20'

f"""He said {"I'm John"}"""#"He said I'm John"

f'5 {"{stars}"}'#'5 {stars}'
f'{{5}} {"stars"}' #'{5} stars'

name = 'Eric'
age = 27
f"""Hello!
...     I'm {name}.
...     I'm {age}."""

#"Hello!\n    I'm Eric.\n    I'm 27."



## Fill align

f'{"text":10}'     # [width]
#'text      '
f'{"test":*>10}'   # fill left
#'******test'
f'{"test":*<10}'   # fill right
#'test******'
f'{"test":*^10}'   # fill center
#'***test***'
f'{12345:0>10}'    # fill with numbers
#'0000012345'


# base convertion

f'{10:b}'        # binary type
#'1010'
f'{10:o}'        # octal type
#'12'
f'{200:x}'       # hexadecimal type
#'c8'
f'{200:X}'
#'C8'
f'{345600000000:e}' # scientific notation
#'3.456000e+11'
f'{65:c}'       # character type
#'A'
f'{10:#b}'      # [type] with notation (base)
#'0b1010'
f'{10:#o}'
#'0o12'
f'{10:#x}'
#'0xa'

"""# List
---

lists are a versatile and commonly used data structure that offer several characteristics:

- `Ordered`: Lists maintain the order of elements as they are inserted. Elements are indexed starting from 0, allowing access by index.

- `Mutable`: Lists are mutable, meaning you can change, add, or remove elements after the list is created.

- `Heterogeneous Elements`: Lists can contain elements of different data types. For example, a single list can hold integers, strings, floats, or even other lists.

- `Dynamic`: Lists can dynamically resize, allowing for the addition or removal of elements, making them flexible for handling different amounts of data.

- `Iterable`: Lists are iterable, allowing you to iterate through their elements using loops or comprehension.
"""

# BAsic Defining

li1 = []
li1
#[]
li2 = [4, 5, 6]
li2
#[4, 5, 6]
li3 = list((1, 2, 3))
li3
#[1, 2, 3]
li4 = list(range(1, 11))
li4
#[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

# append

li = []
li.append(1)
li
#[1]
li.append(2)
li
#[1, 2]
li.append(4)
li
#[1, 2, 4]
li.append(3)
li
#[1, 2, 4, 3]


#Pop


li = ['bread', 'butter', 'milk']
li.pop()
#'milk'
li
#['bread', 'butter']
del li[0]
li
#['butter']


# Concatenating

odd = [1, 3, 5]
odd.extend([9, 11, 13])
odd
#[1, 3, 5, 9, 11, 13]
odd = [1, 3, 5]
odd + [9, 11, 13]
#[1, 3, 5, 9, 11, 13]


# generate

list(filter(lambda x : x % 2 == 1, range(1, 20)))
#[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]

[x ** 2 for x in range (1, 11) if  x % 2 == 1]
#[1, 9, 25, 49, 81]

[x for x in [3, 4, 5, 6, 7] if x > 5]
#[6, 7]

list(filter(lambda x: x > 5, [3, 4, 5, 6, 7]))
#[6, 7]


# slicing

#syntex
# a_list[start:end]
# a_list[start:end:step]

a = ['spam', 'egg', 'bacon', 'tomato', 'ham', 'lobster']
a[2:5]
#['bacon', 'tomato', 'ham']
a[-5:-2]
#['egg', 'bacon', 'tomato']
a[1:4]
#['egg', 'bacon', 'tomato']

# slicing of omitted index

a=['spam', 'egg', 'bacon', 'tomato', 'ham', 'lobster']
a[0:6:2]
#['spam', 'bacon', 'ham']
a[1:6:2]
#['egg', 'tomato', 'lobster']
a[6:0:-2]
#['lobster', 'tomato', 'egg']
a
#['spam', 'egg', 'bacon', 'tomato', 'ham', 'lobster']
a[::-1]
#['lobster', 'ham', 'tomato', 'bacon', 'egg', 'spam']


# sort and reverse and count and repeating

li = [3, 1, 3, 2, 5]
li.sort()
li
#[1, 2, 3, 3, 5]
li.reverse()
li
#[5, 3, 3, 2, 1]

li.count(3)

li = ["re"] * 3
li
#['re', 're', 're']

"""# Tuples:

Tuples in Python share some characteristics with lists but have a few key differences:

- `Immutable:` Unlike lists, tuples are immutable, meaning once created, their elements cannot be changed, added, or removed. However, if an element is mutable (e.g., a list within a tuple), the contents of that mutable element can be modified.

- `Ordered:` Similar to lists, tuples maintain the order of elements as they are inserted and allow access by index. Elements in a tuple are indexed starting from 0.

- `Heterogeneous Elements:` Tuples can contain elements of different data types, just like lists. Elements can be of any data type, including numbers, strings, tuples, lists, or other objects.

- `Creation and Use:` Tuples are often used for fixed collections of items where immutability is desired. For instance, they are suitable for representing coordinates, dates, pairs of values, and situations where the data should not be changed accidentally.

- `Memory Efficiency:` Tuples generally consume less memory compared to lists because they are immutable and have a fixed size.



"""

#Similar to List but immutable
my_tuple = (1, 2, 3)
my_tuple = tuple((1, 2, 3))

"""# set


Sets in Python have several characteristics:

- `Unordered Collection:` Sets are unordered collections of unique elements. They do not maintain the order of insertion of elements.

- `Unique Elements:` Sets do not allow duplicate elements. If an element is added to a set that already exists, it won't be added again.

- `Mutable:` Sets are mutable, meaning you can add or remove elements after the set is created.

- `Iterable:` You can iterate over the elements of a set using loops or comprehensions.

- `Membership Testing:` Sets offer fast membership testing. Checking if an element is present in a set is significantly faster than checking in other collections like lists or tuples.

- `Mathematical Set Operations:` Sets support various mathematical set operations such as union, intersection, difference, and symmetric difference.
"""

set1 = {"a", "b", "c"}
set2 = set(("a", "b", "c"))

"""# Dictionary:

- Key: Value pair, JSON like object
"""

empty_dict = {}
a = {"one": 1, "two": 2, "three": 3}
a["one"]
#1
a.keys()
#dict_keys(['one', 'two', 'three'])
a.values()
#dict_values([1, 2, 3])
a.update({"four": 4})
a.keys()
# dict_keys(['one', 'two', 'three', 'four'])
a['four']
#4

"""# Loops"""

primes = [2, 3, 5, 7]
for prime in primes:
    print(prime)

animals = ["dog", "cat", "mouse"]
# enumerate() adds counter to an iterable
for i, value in enumerate(animals):
    print(i, value)


x = 0
while x < 4:
    print(x)
    x += 1  # Shorthand for x = x + 1


x = 0
for index in range(10):
    x = index * 10
    if index == 5:
    	break
    print(x)


# ranges

for i in range(4):
    print(i) # Prints: 0 1 2 3

for i in range(4, 8):
    print(i) # Prints: 4 5 6 7

for i in range(4, 10, 2):
    print(i) # Prints: 4 6 8


# with zip

words = ['Mon', 'Tue', 'Wed']
nums = [1, 2, 3]
# Use zip to pack into a tuple list
for w, n in zip(words, nums):
    print('%d:%s, ' %(n, w)) # 1:Mon, 2:Tue, 3:Wed,